<HTML>
<HEAD>
<TITLE>Perl::Critic::Utils</TITLE>
<LINK href="/styles/pod.css" type="text/css" rel="stylesheet"></HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<UL>
<LI><A HREF="#NAME">NAME

</A><LI><A HREF="#DESCRIPTION">DESCRIPTION

</A><LI><A HREF="#EXPORTED%20SUBS">EXPORTED SUBS

</A><LI><A HREF="#EXPORTED%20VARIABLES">EXPORTED VARIABLES

</A><LI><A HREF="#AUTHOR">AUTHOR

</A><LI><A HREF="#COPYRIGHT">COPYRIGHT

</A></UL>
<HR>
<H1><A NAME="NAME">NAME

</A></H1>

<P>Perl::Critic::Utils - Utility subs and vars for Perl::Critic

</P><HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>

<P>This module exports several static subs and variables that are useful
for developing <A HREF="../../Perl/Critic/Policy.html">Perl::Critic::Policy</A> subclasses.  Unless you are
writing Policy modules, you probably don't care about this package.

</P><HR>
<H1><A NAME="EXPORTED%20SUBS">EXPORTED SUBS

</A></H1>
<DL><DT><A NAME="find_keywords(%20%24doc%2c%20%24keyword%20)"><CODE>find_keywords( $doc, $keyword )</CODE>

</A></DT>
<DD>

<P><B>DEPRECATED:</B> Since version 0.11, every Policy is evaluated at each
element of the document.  So you shouldn't need to go looking for a
particular keyword.

</P>
<P>Given a <A HREF="../../PPI/Document.html">PPI::Document</A> as <CODE>$doc</CODE>, returns a reference to an array
containing all the <A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A> elements that match
<CODE>$keyword</CODE>.  This can be used to find any built-in function, method
call, bareword, or reserved keyword.  It will not match variables,
subroutine names, literal strings, numbers, or symbols.  If the
document doesn't contain any matches, returns undef.

</P></DD>
<DT><A NAME="is_perl_global(%20%24element%20)"><CODE>is_perl_global( $element )</CODE>

</A></DT>
<DD>
Given a <A HREF="../../PPI/Token/Symbol.html">PPI::Token::Symbol</A> or a string, returns true if that token
represents one of the global variables provided by the <A HREF="../../English.html">English</A>
module, or one of the builtin global variables like <CODE>%SIG</CODE>, <CODE>%ENV</CODE>,
or <CODE>@ARGV</CODE>.  The sigil on the symbol is ignored, so things like
<CODE>$ARGV</CODE> or <CODE>$ENV</CODE> will still return true.

</DD>
<DT><A NAME="is_perl_builtin(%20%24element%20)"><CODE>is_perl_builtin( $element )</CODE>

</A></DT>
<DD>
Given a <A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A> or a string, returns true if that token
represents a call to any of the builtin functions defined in Perl
5.8.8

</DD>
<DT><A NAME="precedence_of(%20%24element%20)"><CODE>precedence_of( $element )</CODE>

</A></DT>
<DD>
Given a <A HREF="../../PPI/Token/Operator.html">PPI::Token::Operator</A> or a string, returns the precedence of
the operator, where 1 is the highest precedence.  Returns undef if the
precedence can't be determined (which is usually because it is not an
operator).

</DD>
<DT><A NAME="is_hash_key(%20%24element%20)"><CODE>is_hash_key( $element )</CODE>

</A></DT>
<DD>

<P>Given a <A HREF="../../PPI/Element.html">PPI::Element</A>, returns true if the element is a hash key.
PPI doesn't distinguish between regular barewords (like keywords or
subroutine calls) and barewords in hash subscripts (which are
considered literal).  So this subroutine is useful if your Policy is
searching for <A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A> elements and you want to filter out
the hash subscript variety.  In both of the following examples, 'foo'
is considered a hash key:

</P>
<PRE>  $hash1{foo} = 1;
  %hash2 = (foo =&gt; 1);</PRE>
</DD>
<DT><A NAME="is_method_call(%20%24element%20)"><CODE>is_method_call( $element )</CODE>

</A></DT>
<DD>
Given a <A HREF="../../PPI/Element.html">PPI::Element</A> that is presumed to be a function call (which
is usually a <A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A>), returns true if the function is a
method being called on some reference.  Basically, it just looks to see
if the preceding operator is &quot;-&gt;&quot;.  This is useful for distinguishing
static function calls from object method calls.

</DD>
<DT><A NAME="is_subroutine_name(%20%24element%20)"><CODE>is_subroutine_name( $element )</CODE>

</A></DT>
<DD>
Given a <A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A>, returns true if the element is the name
of a subroutine declaration.  This is useful for distinguishing
barewords and from function calls from subroutine declarations.

</DD>
<DT><A NAME="is_function_call(%20%24element%20)"><CODE>is_function_call( $element )</CODE>

</A></DT>
<DD>
Given a <A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A> returns true if the element appears to be
call to a static function.  Specifically, this function returns true
if <CODE>is_hash_key</CODE>, <CODE>is_method_call</CODE>, and <CODE>is_subroutine_name</CODE> all
return false for the given element.

</DD>
<DT><A NAME="parse_arg_list(%20%24element%20)"><CODE>parse_arg_list( $element )</CODE>

</A></DT>
<DD>
Given a <A HREF="../../PPI/Element.html">PPI::Element</A> that is presumed to be a function call (which
is usually a <A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A>), splits the argument expressions
into arrays of tokens.  Returns a list containing references to each
of those arrays.  This is useful because parens are optional when
calling a function, and PPI parses them very differently.  So this
method is a poor-man's parse tree of PPI nodes.  It's not bullet-proof
because it doesn't respect precedence.  In general, I don't like the
way this function works, so don't count on it to be stable (or even
present).

</DD>
<DT><A NAME="is_script(%20%24document%20)"><CODE>is_script( $document )</CODE>

</A></DT>
<DD>
Given a <A HREF="../../PPI/Document.html">PPI::Document</A>, test if it starts with <CODE>/#!.*perl/</CODE>.  If so,
it is judged to be a script instead of a module.

</DD>
<DT><A NAME="all_perl_files(%20%40directories%20)"><CODE>all_perl_files( @directories )</CODE>

</A></DT>
<DD>

<P>Given a list of directories, recursively searches through all the
directories (depth first) and returns a list of paths for all the
files that are Perl code files.  Any administrative files for CVS or
Subversion are skipped, as are things that look like temporary or
backup files.

</P>
<P>A Perl code file is:

</P><DL><DT><A NAME="*%20Any%20file%20that%20ends%20in%20.PL%2c%20.pl%2c%20.pm%2c%20or%20.t">* Any file that ends in <I>.PL</I>, <I>.pl</I>, <I>.pm</I>, or <I>.t</I>

</A></DT>
<DD>
</DD>
<DT><A NAME="*%20Any%20file%20that%20has%20a%20first%20line%20with%20a%20shebang%20containing%20'perl'">* Any file that has a first line with a shebang containing 'perl'

</A></DT>
<DD>
</DD>
</DL>
</DD>
<DT><A NAME="verbosity_to_format(%20%24verbosity_level%20)"><CODE>verbosity_to_format( $verbosity_level )</CODE>

</A></DT>
<DD>
Given a verbosity level between 1 and 10, returns the corresponding
predefined format string.  These formats are suitable for passing to
the <CODE>set_format</CODE> method in <A HREF="../../Perl/Critic/Violation.html">Perl::Critic::Violation</A>.  See the
<A HREF="../../perlcritic.html">perlcritic</A> documentation for a listing of the predefined formats.

</DD>
<DT><A NAME="hashify(%20%40list%20)"><CODE>hashify( @list )</CODE>

</A></DT>
<DD>
Given <CODE>@list</CODE>, return a hash where <CODE>@list</CODE> is in the keys and
each value is 1.

</DD>
</DL>
<HR>
<H1><A NAME="EXPORTED%20VARIABLES">EXPORTED VARIABLES

</A></H1>
<DL><DT><A NAME="%40BUILTINS"><CODE>@BUILTINS</CODE>

</A></DT>
<DD>

<P><B>DEPRECATED:</B>  Use <CODE>is_perl_builtin()</CODE> instead.

</P>
<P>This is a list of all the built-in functions provided by Perl 5.8.  I
imagine this is useful for distinguishing native and non-native
function calls.

</P></DD>
<DT><A NAME="%40GLOBALS"><CODE>@GLOBALS</CODE>

</A></DT>
<DD>

<P><B>DEPRECATED:</B>  Use <CODE>is_perl_global()</CODE> instead.

</P>
<P>This is a list of all the magic global variables provided by the
<A HREF="../../English.html">English</A> module.  Also includes commonly-used global like <CODE>%SIG</CODE>,
<CODE>%ENV</CODE>, and <CODE>@ARGV</CODE>.  The list contains only the variable name,
without the sigil.

</P></DD>
<DT><A NAME="%24COMMA"><CODE>$COMMA</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24FATCOMMA"><CODE>$FATCOMMA</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24COLON"><CODE>$COLON</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24SCOLON"><CODE>$SCOLON</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24QUOTE"><CODE>$QUOTE</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24DQUOTE"><CODE>$DQUOTE</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24PERIOD"><CODE>$PERIOD</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24PIPE"><CODE>$PIPE</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24EMPTY"><CODE>$EMPTY</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24SPACE"><CODE>$SPACE</CODE>

</A></DT>
<DD>
These character constants give clear names to commonly-used strings
that can be hard to read when surrounded by quotes.

</DD>
<DT><A NAME="%24SEVERITY_HIGHEST"><CODE>$SEVERITY_HIGHEST</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24SEVERITY_HIGH"><CODE>$SEVERITY_HIGH</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24SEVERITY_MEDIUM"><CODE>$SEVERITY_MEDIUM</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24SEVERITY_LOW"><CODE>$SEVERITY_LOW</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24SEVERITY_LOWEST"><CODE>$SEVERITY_LOWEST</CODE>

</A></DT>
<DD>
These numeric constants define the relative severity of violating each
<A HREF="../../Perl/Critic/Policy.html">Perl::Critic::Policy</A>.  The <CODE>get_severity</CODE> and <CODE>default_severity</CODE>
methods of every Policy subclass must return one of these values.

</DD>
<DT><A NAME="%24TRUE"><CODE>$TRUE</CODE>

</A></DT>
<DD>
</DD>
<DT><A NAME="%24FALSE"><CODE>$FALSE</CODE>

</A></DT>
<DD>
These are simple booleans. 1 and 0 respectively.  Be mindful of using these
with string equality.  <CODE>$FALSE ne $EMPTY</CODE>.

</DD>
</DL>
<HR>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>

<P>Jeffrey Ryan Thalhammer &lt;thaljef@cpan.org&gt;

</P><HR>
<H1><A NAME="COPYRIGHT">COPYRIGHT

</A></H1>

<P>Copyright (c) 2005-2006 Jeffrey Ryan Thalhammer.  All rights reserved.

</P>
<P>This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the LICENSE file included with this module.

</P>
</BODY>
</HTML>
