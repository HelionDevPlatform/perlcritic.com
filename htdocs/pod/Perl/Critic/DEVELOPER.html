<HTML>
<HEAD>
<TITLE>Perl::Critic::DEVELOPER</TITLE>
<LINK href="/styles/pod.css" type="text/css" rel="stylesheet"></HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<UL>
<LI><A HREF="#NAME">NAME

</A><LI><A HREF="#DESCRIPTION">DESCRIPTION

</A><LI><A HREF="#BACKGROUND">BACKGROUND

</A><LI><A HREF="#EXAMPLE%20POLICY">EXAMPLE POLICY

</A><LI><A HREF="#AUTHOR">AUTHOR

</A><LI><A HREF="#COPYRIGHT">COPYRIGHT

</A></UL>
<HR>
<H1><A NAME="NAME">NAME

</A></H1>

<P>Perl::Critic::DEVELOPER - How to make new Perl::Critic::Policy modules

</P><H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>

<P>This document describes how to create a new Policy module for
<A HREF="../../Perl/Critic.html">Perl::Critic</A>.  It is intended for developers who wish to extend
Perl::Critic to enforce their own custom coding standards.  Although
the Perl::Critic distribution already includes a number of Policies
based on Damian Conway's book &quot;Perl Best Practices&quot;, Perl::Critic is
not limited to his guidelines and can be used to enforce any practice,
preference, or style that you want to follow.  In fact, you can even
write Policies to enforce contradictory guidelines.  All you need to
do is write a corresponding <A HREF="../../Perl/Critic/Policy.html">Perl::Critic::Policy</A> subclass, which
may require as little as 10 lines of code..

</P><H1><A NAME="BACKGROUND">BACKGROUND

</A></H1>

<P>The heart of Perl::Critic is <A HREF="../../PPI.html">PPI</A>, which is a parser and lexer for
Perl.  PPI transforms a file of Perl source code into a Document
Object Model (DOM).  Each token in the document is represented by one
of the various PPI classes (for example: <A HREF="../../PPI/Token/Operator.html">PPI::Token::Operator</A>,
<A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A>).  The tokens are then organized into a hierarchy
of structural classes (for example: <A HREF="../../PPI/Statement/Expression.html">PPI::Statement::Expression</A>,
<A HREF="../../PPI/Structure/Subroutine.html">PPI::Structure::Subroutine</A>).  The root node of the hierarchy is the
<A HREF="../../PPI/Document.html">PPI::Document</A>.

</P>
<P>The <A HREF="../../Perl/Critic.html">Perl::Critic</A> engine traverses each node in the <A HREF="../../PPI/Document.html">PPI::Document</A>
tree and invokes each of the <A HREF="../../Perl/Critic/Policy.html">Perl::Critic::Policy</A> subclasses at the
appropriate node.  The Policy can inspect the node, look at the
surrounding nodes, and do whatever else it wants.  If the Policy
decides that that a coding standard has been violated, it returns one
or more <A HREF="../../Perl/Critic/Violation.html">Perl::Critic::Violation</A> objects.  If there are no
violations, then the Policy returns nothing.

</P>
<P>So now that we understand the basic organization of PPI and
Perl::Critic, lets examine one the existing Policy modules so we can
see how this all works.  We will pick the <I>RequireBlockGrep.pm</I>
policy because it is relatively simple but demonstrates most of the
important issues.  The goal of this Policy is to enforce that every
call to <CODE>grep</CODE> uses a block for the first argument and not an
expression.  The reasons for this Policy are discussed in detail in
&quot;Perl Best Practices.&quot;

</P><H1><A NAME="EXAMPLE%20POLICY">EXAMPLE POLICY

</A></H1>

<P>First, the Policy module needs to have a name.  Perl::Critic uses
<A HREF="../../Module/Pluggable.html">Module::Pluggable</A> to automatically discover all modules that are in
the <CODE>Perl::Critic::Policy</CODE> namespace.  Also, we've adopted the
convention of grouping Policies into directories according to the
table of contents in Conway's book &quot;Perl Best Practices.&quot;  Since the
goal of this policy is to enforce the use of block arguments to
<CODE>grep</CODE> and it comes from the &quot;Builtin Functions&quot; chapter of PBP, we
call it &quot;Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep&quot;.

</P>
<PRE>  package Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep;</PRE>

<P>Next, we set some pragmas and load the modules that we'll need.  All
Policy modules inherit from the <A HREF="../../Perl/Critic/Policy.html">Perl::Critic::Policy</A> class, which
provides no-op implementations of the basic methods.  Our job is to
override these methods to make them do something useful.

</P>
<P>Technically, <CODE>use strict</CODE> and <CODE>use warnings</CODE> are optional, but they
are necessary to make Perl::Critic self-compliant.  And we don't want
Perl::Critic to be a hypocrite, now do we?

</P>
<PRE>  use strict;
  use warnings;
  use Perl::Critic::Utils;
  use Perl::Critic::Violation;
  use base 'Perl::Critic::Policy';

  our $VERSION = '0.13_01';</PRE>

<P>Next, we'll declare a description and explanation for this Policy.
The description is always just a string that basically says &quot;this is
what's wrong.&quot;  The explanation can be either a string with further
details, or a reference to an array of integers that correspond to
page numbers in the &quot;Perl Best Practices&quot; book.

</P>
<PRE>  my $desc = q{Expression form of &quot;grep&quot;};
  my $expl = [169];</PRE>

<P>Most policies don't need to override the new() method provided by
<A HREF="../../Perl/Critic/Policy.html">Perl::Critic::Policy</A>.  However, if your policy is configurable via
<I>.perlcriticrc</I> you will need to override the constructor to examine
the <CODE>%args</CODE> values.  See
<A HREF="../../Perl/Critic/Policy/ControlStructures/ProhibitCascadingIfElse.html">Perl::Critic::Policy::ControlStructures::ProhibitCascadingIfElse</A>
for a simple example and
<A HREF="../../Perl/Critic/Policy/Documentation/RequirePodSections.html">Perl::Critic::Policy::Documentation::RequirePodSections</A> for a more
complex example.

</P>
<P>Next we define the <CODE>default_severity()</CODE> method, which should return a
scalar value indicating the severity of violating this Policy.
Severity values range from 1 to 5, where 5 is the &quot;most severe.&quot;  In
general, level 5 is reserved for things that are frequently misused
and/or cause bugs.  Level 1 is for things that are highly subjective or
purely cosmetic.  The <A HREF="../../Perl/Critic/Utils.html">Perl::Critic::Utils</A> package exports several
severity constants that you can use here.

</P>
<PRE>  sub default_severity  { return $SEVERITY_HIGH }</PRE>

<P>Likewise, the <CODE>default_themes()</CODE> method returns a list of theme
names.  Themes are intended to be named groups of Policies.  Since
this Policy comes directly from Damian's &quot;Perl Best Practices&quot; book,
this Policy should be a member of the <CODE>pbp</CODE> theme.  As a Policy
author, you can specify any themes you want.

</P>
<PRE>  sub default_themes { return qw( pbp ) }</PRE>

<P>Next we indicate what parts of the code this policy will analyze, like
statements or variables or conditionals or POD.  These parts are
specified as PPI classes like <A HREF="../../PPI/Statement.html">PPI::Statement</A>,
<A HREF="../../PPI/Token/Symbol.html">PPI::Token::Symbol</A>, <A HREF="../../PPI/Structure/Conditional.html">PPI::Structure::Conditional</A> or
<A HREF="../../PPI/Token/Pod.html">PPI::Token::Pod</A> respectively.  The applies_to() method returns a
list of PPI package names.  (You can get that list of package names
via <CODE>perldoc PPI</CODE>.)  As Perl::Critic traverses the document, it will
call the <CODE>violates()</CODE> method from this module whenever it encounters
one of the PPI types that are given here.  In this case, we just want
to test calls to <CODE>grep</CODE>.  Since the token &quot;grep&quot; is a
<A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A>, we return that name from the <CODE>applies_to()</CODE>
method.

</P>
<PRE>  sub applies_to { return 'PPI::Token::Word' }</PRE>

<P>Note that applies_to() is purely a performance enhancement -- if you
want your policy to analyze every <A HREF="../../PPI/Element.html">PPI::Element</A>, that's just fine.

</P>
<P>Now comes the interesting part.  The <CODE>violates()</CODE> method does all the
work.  It is always called with 2 arguments: a reference to the
current PPI element instance that Perl::Critic is traversing, and a
reference to the entire PPI document. [And since this is an instance
method, there will be an additional argument that is a reference to
this object (<CODE>$self</CODE>), but you already knew that!]

</P>
<PRE>  sub violates {
      my ( $self, $elem, $doc ) = @_;</PRE>

<P>The violates() method then often performs some tests to make sure we
have the right &quot;type&quot; of element.  In our example, we know that the
element will be a <A HREF="../../PPI/Token/Word.html">PPI::Token::Word</A> because that's what we declared
back in the <CODE>applies_to()</CODE> method.  However, we didn't specify
exactly which &quot;word&quot; we were looking for.  Evaluating a PPI element in
a string context returns the literal form of the code.  So we make
sure that this PPI::Token::Word is, in fact, &quot;grep&quot;.  If it's not,
then we don't' need to bother examining it.

</P>
<PRE>    return if !($elem eq 'grep');</PRE>

<P>The <CODE>PPI::Token::Word</CODE> class is also used for barewords and methods
called on object references.  It is possible for someone to declare a
bareword hash key as <CODE>&lt;%hash = ( grep =</CODE> 'foo' )&gt;&gt;.  We don't want to
test those types of elements because they don't represent function
calls to <CODE>grep</CODE>.  So we use some handy utility functions from
<A HREF="../../Perl/Critic/Utils.html">Perl::Critic::Utils</A> to make sure that this &quot;grep&quot; is actually in
the right context.

</P>
<PRE>    return if is_method_call($elem);
    return if is_hash_key($elem);
    return if is_subroutine_name($elem);</PRE>

<P>Now that we know this element is a call to the <CODE>grep</CODE> function, we can
look at the nearby elements to see what kind of arguments are being
passed to it.  Every PPI element is linked to its siblings, parent,
and children (if it has any).  Since those siblings could just be
whitespace, we use the <CODE>snext_sibling()</CODE> to get the next code-sibling
(the 's' in <CODE>snext_sibling</CODE> stands for 'significant').

</P>
<PRE>    my $sib = $elem-&gt;snext_sibling() || return;</PRE>

<P>In Perl, the parenthesis around argument lists are usually optional,
and PPI packs the elements into a <A HREF="../../PPI/Structure/List.html">PPI::Structure::List</A> object when
parens are used.  So if the sibling is a PPI::Structure::List, we pull
out the first (significant) child of that list.  This child will be
the first argument to <CODE>grep</CODE>.  If parens were not used, then the
sibling itself is the first argument.

</P>
<PRE>    my $arg = $sib-&gt;isa('PPI::Structure::List') ? $sib-&gt;schild(0) : $sib;</PRE>

<P>Finally, we now have a reference to the first argument to <CODE>grep</CODE>.  If
that argument is a block (i.e. something in curly braces), then it
will be a <A HREF="../../PPI/Structure/Block.html">PPI::Structure::Block</A>, in which case our Policy is
satisfied and we just return nothing.

</P>
<PRE>    return if !$arg || $arg-&gt;isa('PPI::Structure::Block');</PRE>

<P>But if it is not a <A HREF="../../PPI/Structure/Block.html">PPI::Structure::Block</A>, then we know that this
call to <CODE>grep</CODE> must be using the expression form, and that violates
our Policy.  So we create and return a new <A HREF="../../Perl/Critic/Violation.html">Perl::Critic::Violation</A>
object, passing in the description, explanation, and severity of the
violation, as well as a reference to the PPI element that caused the
violation.  And that's all there is to it!

</P>
<PRE>    my $sev = $self-&gt;get_severity();
    return Perl::Critic::Violation-&gt;new( $desc, $expl, $elem, $sev );
  }

  1;</PRE>

<P>One last thing -- When you import <A HREF="../../Perl/Critic/Violation.html">Perl::Critic::Violation</A>, it extracts
the DESCRIPTION section from the POD in your Policy module.  That text
can displayed in the diagnostic output when the Violations objects are
stringified.  So please include a DESCRIPTION section in the POD for
your Policy.  It should succinctly describe the behavior and
motivation for your Policy and include a few examples of both good and
bad code.  Here's an example:

</P>
<PRE>  =pod

  =head1 NAME

  Perl::Critic::Policy::BuiltinFunctions::RequireBlockGrep

  =head1 DESCRIPTION

  The expression form of C&lt;grep&gt; and C&lt;map&gt; is awkward and hard to read.
  Use the block forms instead.

    @matches = grep   /pattern/,   @list;        #not ok
    @matches = grep { /pattern/ }  @list;        #ok

    @mapped = map   transform($_),   @list;      #not ok
    @mapped = map { transform($_) }  @list;      #ok

  =cut</PRE>
<H1><A NAME="AUTHOR">AUTHOR

</A></H1>

<P>Jeffrey Ryan Thalhammer &lt;thaljef@cpan.org&gt;

</P><H1><A NAME="COPYRIGHT">COPYRIGHT

</A></H1>

<P>Copyright (c) 2005-2006 Jeffrey Ryan Thalhammer.  All rights reserved.

</P>
<P>This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the LICENSE file included with this module.

</P>
</BODY>
</HTML>
