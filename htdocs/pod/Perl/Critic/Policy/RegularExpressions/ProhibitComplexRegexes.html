<HTML>
<HEAD>
<TITLE>NAME</TITLE>
<LINK href="/styles/pod.css" type="text/css" rel="stylesheet"></HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<UL>
<LI><A HREF="#NAME">NAME

</A><LI><A HREF="#AFFILIATION">AFFILIATION

</A><LI><A HREF="#DESCRIPTION">DESCRIPTION

</A><LI><A HREF="#CASE%20STUDY">CASE STUDY

</A><LI><A HREF="#CONFIGURATION">CONFIGURATION

</A><LI><A HREF="#PREREQUISITES">PREREQUISITES

</A><LI><A HREF="#CREDITS">CREDITS

</A><LI><A HREF="#AUTHOR">AUTHOR

</A><LI><A HREF="#COPYRIGHT">COPYRIGHT

</A></UL>
<HR>
<H1><A NAME="NAME">NAME

</A></H1>

<P>Perl::Critic::Policy::RegularExpressions::ProhibitComplexRegexes - Split long regexps into smaller <CODE>qr//</CODE> chunks.


</P><H1><A NAME="AFFILIATION">AFFILIATION

</A></H1>

<P>This Policy is part of the core <A HREF="Perl/Critic.html">Perl::Critic</A>
distribution.


</P><H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>

<P>Big regexps are hard to read, perhaps even the hardest part of Perl.
A good practice to write digestible chunks of regexp and put them
together.  This policy flags any regexp that is longer than <CODE>N</CODE>
characters, where <CODE>N</CODE> is a configurable value that defaults to 60.
If the regexp uses the <CODE>x</CODE> flag, then the length is computed after
parsing out any comments or whitespace.


</P><H1><A NAME="CASE%20STUDY">CASE STUDY

</A></H1>

<P>As an example, look at the regexp used to match email addresses in
<A HREF="Email/Valid/Loose.html">Email::Valid::Loose</A> (tweaked lightly to wrap
for POD)

</P>
<PRE>    (?x-ism:(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]
    \000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n\015
    &quot;]*)*&quot;)(?:(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[
    \]\000-\037\x80-\xff])|&quot;[^\\\x80-\xff\n\015&quot;]*(?:\\[^\x80-\xff][^\\\x80-\xff\n
    \015&quot;]*)*&quot;)|\.)*\@(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,
    ;:&quot;.\\\[\]\000-\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]
    )(?:\.(?:[^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000-\037\x80-\xff]+(?![^(\040)&lt;&gt;@,;:&quot;.\\\[\]\000
    -\037\x80-\xff])|\[(?:[^\\\x80-\xff\n\015\[\]]|\\[^\x80-\xff])*\]))*)</PRE>

<P>which is constructed from the following code:

</P>
<PRE>    my $esc         = '\\\\';
    my $period      = '\.';
    my $space       = '\040';
    my $open_br     = '\[';
    my $close_br    = '\]';
    my $nonASCII    = '\x80-\xff';
    my $ctrl        = '\000-\037';
    my $cr_list     = '\n\015';
    my $qtext       = qq/[^$esc$nonASCII$cr_list\&quot;]/; # &quot;
    my $dtext       = qq/[^$esc$nonASCII$cr_list$open_br$close_br]/;
    my $quoted_pair = qq&lt;$esc&gt;.qq&lt;[^$nonASCII]&gt;;
    my $atom_char   = qq/[^($space)&lt;&gt;\@,;:\&quot;.$esc$open_br$close_br$ctrl$nonASCII]/;# &quot;
    my $atom        = qq&lt;$atom_char+(?!$atom_char)&gt;;
    my $quoted_str  = qq&lt;\&quot;$qtext*(?:$quoted_pair$qtext*)*\&quot;&gt;; # &quot;
    my $word        = qq&lt;(?:$atom|$quoted_str)&gt;;
    my $domain_ref  = $atom;
    my $domain_lit  = qq&lt;$open_br(?:$dtext|$quoted_pair)*$close_br&gt;;
    my $sub_domain  = qq&lt;(?:$domain_ref|$domain_lit)&gt;;
    my $domain      = qq&lt;$sub_domain(?:$period$sub_domain)*&gt;;
    my $local_part  = qq&lt;$word(?:$word|$period)*&gt;; # This part is modified
    $Addr_spec_re   = qr&lt;$local_part\@$domain&gt;;</PRE>

<P>If you read the code from bottom to top, it is quite readable.  And,
you can even see the one violation of RFC822 that Tatsuhiko Miyagawa
deliberately put into Email::Valid::Loose to allow periods.  Look for
the <CODE>|\.</CODE> in the upper regexp to see that same deviation.

</P>
<P>One could certainly argue that the top regexp could be re-written more
legibly with <CODE>m//x</CODE> and comments.  But the bottom version is
self-documenting and, for example, doesn't repeat <CODE>\x80-\xff</CODE> 18
times.  Furthermore, it's much easier to compare the second version
against the source BNF grammar in RFC 822 to judge whether the
implementation is sound even before running tests.


</P><H1><A NAME="CONFIGURATION">CONFIGURATION

</A></H1>

<P>This policy allows regexps up to <CODE>N</CODE> characters long, where <CODE>N</CODE>
defaults to 60.  You can override this to set it to a different number
with the <CODE>max_characters</CODE> setting.  To do this, put entries in a
<I>.perlcriticrc</I> file like this:

</P>
<PRE>    [RegularExpressions::ProhibitComplexRegexes]
    max_characters = 40
</PRE>
<H1><A NAME="PREREQUISITES">PREREQUISITES

</A></H1>

<P>This policy will disable itself if <A HREF="Regexp/Parser.html">Regexp::Parser</A> is not
installed.


</P><H1><A NAME="CREDITS">CREDITS

</A></H1>

<P>Initial development of this policy was supported by a grant from the
Perl Foundation.


</P><H1><A NAME="AUTHOR">AUTHOR

</A></H1>

<P>Chris Dolan &lt;cdolan@cpan.org&gt;


</P><H1><A NAME="COPYRIGHT">COPYRIGHT

</A></H1>

<P>Copyright (c) 2007-2009 Chris Dolan.  Many rights reserved.

</P>
<P>This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  The full text of this license
can be found in the LICENSE file included with this module

</P>
</BODY>
</HTML>
