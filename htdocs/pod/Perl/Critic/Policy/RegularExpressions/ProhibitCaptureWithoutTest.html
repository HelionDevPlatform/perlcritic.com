<HTML>
<HEAD>
<TITLE>Perl::Critic::Policy::RegularExpressions::ProhibitCaptureWithoutTest</TITLE>
<BASE href="http://perlcritic.com/pod"><LINK href="/styles/pod.css" type="text/css" rel="stylesheet"></HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<UL>
<LI><A HREF="#NAME">NAME

</A><LI><A HREF="#AFFILIATION">AFFILIATION

</A><LI><A HREF="#DESCRIPTION">DESCRIPTION

</A><LI><A HREF="#CONFIGURATION">CONFIGURATION

</A><LI><A HREF="#BUGS">BUGS

</A><LI><A HREF="#AUTHOR">AUTHOR

</A><LI><A HREF="#COPYRIGHT">COPYRIGHT

</A></UL>
<HR>
<H1><A NAME="NAME">NAME

</A></H1>

<P>Perl::Critic::Policy::RegularExpressions::ProhibitCaptureWithoutTest - Capture variable used outside conditional.


</P><H1><A NAME="AFFILIATION">AFFILIATION

</A></H1>

<P>This Policy is part of the core <A HREF="../../../../Perl/Critic.html">Perl::Critic</A>
distribution.


</P><H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>

<P>If a regexp match fails, then any capture variables (<CODE>$1</CODE>, <CODE>$2</CODE>,
...) will be undefined.  Therefore it's important to check the return
value of a match before using those variables.

</P>
<P>This policy checks that the previous regexp for which the capture
variable is in-scope is either in a conditional or causes an exception
or other control transfer (i.e. <CODE>next</CODE>, <CODE>last</CODE>, <CODE>redo</CODE>, <CODE>return</CODE>, or
sometimes <CODE>goto</CODE>) if the match fails.

</P>
<P>A <CODE>goto</CODE> is only accepted by this policy if it is a co-routine call
(i.e.  <CODE>goto &amp;foo</CODE>) or a <CODE>goto LABEL</CODE> where the label does not fall
between the <CODE>goto</CODE> and the capture variable in the scope of the
<CODE>goto</CODE>. A computed <CODE>goto</CODE> (i.e. something like <CODE>goto (qw{foo bar
baz})[$i]</CODE>) is not accepted by this policy because its target can not be
statically determined.

</P>
<P>This policy does not check whether that conditional is actually
testing a regexp result, nor does it check whether a regexp actually
has a capture in it.  Those checks are too hard.

</P>
<P>This policy also does not check arbitrarily complex conditionals guarding
regexp results, for pretty much the same reason.  Simple things like

</P>
<PRE> m/(foo)/ or die &quot;No foo!&quot;;
 die &quot;No foo!&quot; unless m/(foo)/;</PRE>

<P>will be handled, but something like

</P>
<PRE> m/(foo) or do {
   ... lots of complicated calculations here ...
   die &quot;No foo!&quot;;
 };</PRE>

<P>are beyond its scope.


</P><H1><A NAME="CONFIGURATION">CONFIGURATION

</A></H1>

<P>By default, this policy considers <CODE>die</CODE>, <CODE>croak</CODE>, and <CODE>confess</CODE> to
throw exceptions. If you have additional subroutines or methods that may
be used in lieu of one of these, you can configure them in your
perlcriticrc as follows:

</P>
<PRE> [RegularExpressions::ProhibitCaptureWithoutTest]
 exception_source = my_exception_generator</PRE>
<H1><A NAME="BUGS">BUGS

</A></H1>

<P>This policy does not recognize named capture variables. Yet.

</P><H1><A NAME="AUTHOR">AUTHOR

</A></H1>

<P>Chris Dolan &lt;cdolan@cpan.org&gt;


</P><H1><A NAME="COPYRIGHT">COPYRIGHT

</A></H1>

<P>Copyright (c) 2006-2010 Chris Dolan.

</P>
<P>This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

</P>
</BODY>
</HTML>
